# POKEMON GO

Es un vídeojuego de realidad aumentada basado en la localización desarrollado por Niantic, Inc.1​2​ para dispositivos iOS y Android. Es un videojuego gratuito pero contiene microtransacciones. El juego consiste en buscar y capturar personajes de la saga Pokemón escondidos en ubicaciones del mundo real y luchar con ellos, lo que implica desplazarse físicamente por las calles de la ciudad para progresar.

La aplicación comporta un elemento de interacción social, ya que promueve reuniones físicas de los usuarios en distintas ubicaciones de sus poblaciones.

![enter image description here](https://im.ziffdavisinternational.com/ign_es/screenshot/default/pokemongender_rw2m.jpg)

Fuente: Forbes.

Las cifras de 'Pokémon Go' durante el año 2016 han quedado reflejadas en ComScore, una famosa web que proporciona datos y estadísticas de muchas empresas. Ha día de hoy, lejos queda la excelente cifra que alcanzó la aplicación durante sus primeros meses de vida, llegando a los 28,5 millones de usuarios el 7 de Julio. A partir de ese momento el número ha descendido notablemente manteniéndose en una media de aproximadamente 10 millones de usuarios hasta diciembre, que cerró el año con poco más de seis millones.

![enter image description here](https://media.redadn.es/imagenes/pokemon-go-android-ios_305212_post.png)

Pokémon GO alcanza los 2.500 millones de dólares en ingresos a nivel mundial
Estados Unidos es el país que más gasta en el título de realidad aumentada, con un 35% del total de los ingresos, lo que supone aproximadamente unos 875 millones de dólares. Por su parte, Japón ocupa la segunda posición con un 29% del total, unos 725 millones de dólares. Alemania cierra el podio con un 6% de gasto, lo que supone unos 150 millones de dólares.

En cuanto al gasto por descarga, Japón ocupa la primera posición con un promedio de 42 millones de dólares. Al país asiático le sigue los Estados Unidos de América, con 9,50 millones de dólares. Además, también se confirma que Pokémon GO alcanzó la séptima plaza en cuanto a ingresos mundiales de juegos para móviles.

## PROBLEMA DETECTADO

Usuarios frustrados al no generarse una mayor experiencia después de determinado nivel.

Los jugadores de mayor nivel tampoco reciben una recompensa adecuada que justifique su inversión de tiempo.

El problema de Pokémon Go es que un entrenador de nivel 1 necesita capturar diez criaturas para subir de nivel, mientras que un jugador superior, de nivel 39, requiere de más de 20.000.

No se logro la fidelizacion de los primeros jugadores.

## Testimonios

El juego no premia con más puntos si se cazan a pokémones más evolucionados en los niveles más altos, algo que consideran desalentador para el jugador.

Para subir del nivel 1 al 2 son necesarios mil puntos de experiencia, pero para ir del 10 al 11 son necesarias 10 mil unidades. Para ir del 29 al 30 se requieren 350 mil puntos.

Lo que hace más difícil esto es que se requieren más puntos de experiencia, pero no se aumenta la forma de ganarlos, por lo que es muy complicado subir de nivel, afirman los jugadores.

## Testimonio Puntual

Esto es lo que sucede al llegar al nivel 30 de Pokémon Go.

Un "gamer" narra su experiencia tras 30 niveles y más de 14 mil pokémon capturados.

“Después de una semana de jugar “Pokémon Go” y llegar al nivel 30, decidí tomarme unos días de descanso y compartir con ustedes algunos pensamientos”, escribió Riggnaros, jugador de Pokémon Go, usuario de “Reddit”, y quien presume haber llegado al nivel 30 y tener en su haber más de 4 mil pokémon.

Sin embargo, en este nivel las cosas ya no son sólo halagos para la aplicación sensación en todo el mundo, pues lo que Riggnaros compartió fue una lista con varias quejas sobre el juego, las cuales hablan de lo difícil que es subir de nivel a partir del piso 25 y que también critican la forma en que la geografía decida qué pokémon hay en cada lugar.

Debido a la experiencia que tiene jugando Pokémon Go, el gamer se dio cuenta de las fallas de la aplicación y publicó una carta de quejas para Niantic, la empresa desarrolladora de la app, que comienza a recibir dardos de los jugadores más avanzados.

Y es que no sólo Riggnaros se ha quejado de este juego, Verigood, quien también está en el nivel 30, coincide en que Pokémon Go se vuelve complicado y tedioso conforme llegan a los niveles más avanzados.

Estas son las principales fallas de Pokémon Go, según este gamer.

El juego no premia con más puntos si se cazan a pokémon más evolucionados en los niveles más altos, algo que considera desalentador para el jugador.

Al principio del juego es muy fácil pasar de nivel, pero conforme se avanza, se torna más complicado alcanzar el siguiente escalón. Para subir del nivel 1 al 2 son necesarios mil puntos de experiencia, pero para ir del 10 al 11 son necesarias 10 mil unidades. Ya ni decir de la transición del 29 al 30, donde se requieren 350 mil puntos.

Lo que hace más difícil esto es que se requieren más puntos de experiencia, pero no se aumenta la manera de ganarlos, por lo que es muy complicado subir de nivel. Comento el usuario de Twitter @Klik_Vox.

En encuestas realizadas con usuarios nuevos detectamos, que la experiencia con la tegnologia es divertida y agradable pero al ya no existir alguna otra recompensa los usuarios eligen eliminar la app.


## Propuesta

1.- Aumentar la experiencia de la realidad aumentada promoviendo la convivencia, mediante la adopción de un pokemon.

           Fundamento

La realidad aumentada es una forma de visión que se lleva a cabo a través de un dispositivo tecnológico, y en la que se combinan elementos propios del mundo físico con elementos virtuales que el dispositivo proporciona en función de la interacción del usuario con el medio.

Otra cuestión clave de la realidad aumentada es que no sólo no sustituye a la realidad visual física del usuario, sino que ésta es una parte muy importante del funcionamiento del dispositivo. Así, éste se comporta en función de la interacción del usuario con el mundo real. Por eso hablamos de realidad “aumentada”, porque el dispositivo lo que hace es incrementar la información que tenemos del mundo físico en el que nos movemos, y no sustituirlo.

![enter image description here](https://img.depor.com/files/ec_article_multimedia_gallery/uploads/2018/02/22/5a8f11addeaca.jpeg)

![enter image description here](https://img.depor.com/files/ec_article_multimedia_gallery/uploads/2018/02/22/5a8f119e980ad.jpeg)

Joshua Dunlop es un artista conceptual que ha compartido una galería de Pokémon imaginados en un ambiente de la vida real.

La siguiente grafica nos muestra el aumento en el interes acerca de REALIDAD AUMENTADA.

![enter image description here](https://fotos.subefotos.com/ebde3aa732a0f0ea148bd2dad9291f1ao.jpg)

La película Detective Pikachu ha sido la película que más recaudación ha conseguido a nivel mundial, adelantando así a _Avengers: Endgame.

Generando así el deseo y la euforia de convivir con un pokemon, situación que se puede aprovechar para mejorar la convivencia mediante la tegnologia de realidad aumentada para poder cuidar alimentar y convivir con un pokemon.

![enter image description here](https://fotos.subefotos.com/4395fc9be6219a98da00aeaf3e805295o.jpg)

La grafica nos muestra que el interes de la pelicula desperto nuevamente el interes en el juego.


2da Propuesta

2.- -Generar Batallas y Misiones promoviendo el uso de tokens go. (Una criptomoneda).

          Fundamento

Los activos en el juego basados ​​en token ofrecen nuevas oportunidades para la creación de valor, mientras que reducir los costos de transacción ofrece márgenes más altos.

Las transacciones con las criptomonedas son instantáneas.

Facilita las transacciones internacionales.

"El mercado de transacciones de criptomonedas todos los dias crece, se expande y más gente invierte en ello. Están creadas para cambiar la forma de consumo de la gente"

las recompensas promoveran la fidelidad y continuidad a la MARCA.

Nuestra interfaz

 PRIMERA FASE

Esta desarrollada, HTML5 nos aporta la estructura básica de nuestro sitio, mejorada y modificada por otras tecnologías como CSS y JavaScript,  CSS u Hojas de Estilo en Cascada (Cascading Style Sheets) se utiliza para controlar la presentación, el formato, y el diseño de nuestra aplicación. Gracias a ella podemos dar forma al estilo que queremos que se muestre.

JavaScript se utiliza para controlar el comportamiento de los diferentes elementos, esto es, aporta funcionalidad, dinámica, a nuestros elementos.

De igual manera se podra visualizar en cualquier dispositivo movil, mediante Media Queries with JavaScript.

Nuestro primer prototipo

![](https://fotos.subefotos.com/b9630a0964da56c3907e07359f9aa623o.jpg)

Obteniendo como retroalimentacion un diseño mas sencillo enfocado en las funciones principales de la primera fase de la interfaz, mostrar, filtrar y ordenar para elegir la adopcion.

PROTOTIPO DE BAJA FIDELIDAD

![](https://fotos.subefotos.com/d80515577147405bdf3ce565fbfd6d3ao.jpg)

PROTOTIPO DE ALTA FIDELIDAD

![](https://fotos.subefotos.com/992c9bb48df5a035a8353f1f44a54dd9o.jpg)

DESPUES DEL PRIMER TESTING ELEGIMOS DARLE IDENTIDAD MEDIANTE UN lOGO

![](https://fontmeme.com/permalink/190707/b0be9d80d889c9a54348361c1c8e7522.png)

HISTORIAS DE USUARIO

1.- EL usuario puede ver a los 151 pokemon de Kanto.
2.- El usuario puede buscar por nombre a alguno de los 151 pokemon de Kanto.
3.- El usuario visualiza alguna estadistica de los 151 pokemon de Kanto.
4.- El usuario puede ver desde cualquier dispositivo movil la appweb.




# Data Lovers

## Índice

- [Preámbulo](#preámbulo)
- [Descripción](#resumen-del-proyecto)
- [Consideraciones generales](#consideraciones-generales)
- [Objetivos de aprendizaje](#objetivos-de-aprendizaje)
- [Parte obligatoria](#parte-obligatoria)
- [Parte opcional](#parte-opcional-hacker-edition)
- [Consideraciones técnicas](#consideraciones-técnicas)
- [Contenido de referencia](#contenido-de-referencia)
- [Checklist](#checklist)

---

## Preámbulo

Según un [estudio de IBM](https://www-01.ibm.com/common/ssi/cgi-bin/ssialias?htmlfid=WRL12345USEN),
el 90% de la data que existe hoy ha sido creada durante los últimos dos años.
Cada día generamos 2.5 trillones de bytes de datos, una cifra sin precedentes.

No obstante, los datos por sí mismos son de poca utilidad. Para que esas
grandes cantidades de datos se conviertan en **información** fácil de leer para
los usuarios, necesitamos entender y procesar estos datos. Una manera simple de
hacerlo es creando _interfaces_ y _visualizaciones_.

En la siguiente imagen, podrás ver cómo con la data que que se ve en la parte
izquierda se puede construir una interfaz amigable y entendible por el usuario.

![json-interfaz](https://lh4.googleusercontent.com/Tn-RPXS26pVvOTdUzRT1KVaJ-_QbFs9SpcGLxSPE43fgbHaXtFgMUInuDt7kV41DkT1j8Tt29V0LxQW7SMtC6digOIhfTXSBKdwI08wUwhD3RAqlwy0hjfmhZ2BFe91mtmCSEqysfgk)

\* Puedes ver el detalle de la data [aquí](https://gist.github.com/lalogf/dd4aa3017a9f8aa8f90dfbca382c4dc9#file-student-json)
y la interfaz construida [aquí](https://app.talento.laboratoria.la/profile/HFOoMpOreBU2psCcjjLg5O2EWEv2).

## Resumen del proyecto

En este proyecto **construirás una _página web_ para visualizar un
_conjunto (set) de datos_** que se adecúe a lo que descubras que tu usuario
necesita.

Esta vez te proponemos una serie de datos de diferentes _temáticas_ para que
explores y decidas con qué temática te interesa trabajar. Hemos elegido
específicamente estos sets de datos porque creemos que se adecúan bien a esta
etapa de tu aprendizaje.

Una vez que definas tu área de interés, entiende quién es tu usuario y qué
necesita saber o ver exactamente; luego podrás construir la interfaz que le
ayude a interactuar y entender mejor esos datos.

Estos son datos que te proponemos:


- [Pokémon](src/data/pokemon/pokemon.json):
  En este set encontrarás una lista con los 151 Pokémon de la región de Kanto,
  junto con sus respectivas estadísticas usadas en el juego [Pokémon GO](pokemongolive.com).
- [Steam noticias](src/data/steam/steam.json):
  Lista noticias relacionadas a los videojuegos presentes en la
  plataforma de [Steam](https://store.steampowered.com/).
- [League of Legends - Challenger leaderboard](src/data/lol/lol.json):
  Este set de datos muestra la lista de jugadores en una liga del
  juego League of Legends (LoL), puedes revisar la documentación de su API en
  este [link](https://developer.riotgames.com/api-methods/).
- [Rick and Morty](src/data/rickandmorty/rickandmorty.json).
  Este set nos proporciona la lista de los personajes de la serie Rick and
  Morty. Puedes revisar la documentación de su API en este [link](https://rickandmortyapi.com).


Como entregable final tendrás una página web que permita **visualizar la data,
filtrarla, ordenarla y hacer algún cálculo agregado**. Como aclaración,
con cálculo agregado nos referimos a distintos cálculos que puedes hacer con
la data que tienes para mostrar información aún más relevante a los usuarios.
Una opción serían cálculos estadísticos como el promedio, el máximo o el mínimo,
por ejemplo, si tenemos una colección que representa a un grupo de personas,
y cada persona está representada como un _objeto_ con una _propiedad_ `altura`,
podríamos elegir calcular la altura promedio en el grupo entre otras cosas.

## Consideraciones generales

- Este proyecto se debe resolver en duplas.
- El proyecto será entregado subiendo tu código a GitHub (commit/push) y la
  interfaz será desplegada usando [GitHub Pages](https://pages.github.com/).
- Tiempo para completarlo: 3 semana divididas en 3 sprints (una entrega del producto funcional al término de cada sprint).

## Objetivos de aprendizaje

El objetivo principal de este proyecto es que aprendas a diseñar y construir una
interfaz web donde se pueda visualizar y manipular data, entendiendo lo que el
usuario necesita.

Dicho en palabras sencillas, aprenderás a:

- Aplicar y profundizar todo lo que aprendiste en el proyecto anterior.
- Pensar en las **necesidades de los usuarios** para crear historias de usuario.
- Escribir y trabajar con **historias de usuario**, sus definiciones de
  terminado (_definition of done_) en la organización y planificación de tu
  trabajo.
- Definir qué data y de qué forma mostrarla en el producto, basándote en
  tu **entendimiento del usuario**.
- Crear productos que sigan los **principios básicos de diseño visual** y
  las **heurísticas de usabilidad**.
- Iterar el diseño del producto, basándote en los resultados de los
  **tests de usabilidad**.
- Manipular **_arreglos_ (_arrays_) y _objetos_ (_objects_)**.
- **Manipular el DOM** (agregar elementos dinámicamente basados en la data).
- **Manejar eventos del DOM** para permitir interacción con el usuario
  (filtrado, ordenado, ...).
- Entender los beneficios y complejidades de **trabajar en equipo** en un
  ambiente de incertidumbre.

## Alcances esperados

Los criterios para considerar que has completado este proyecto son:

### Definición del producto

Documenta brevemente tu trabajo en el archivo `README.md` de tu repositorio,
contándonos cómo fue tu proceso de diseño y cómo crees que el producto resuelve
el problema (o problemas) que tiene tu usuario.

### Historias de usuario

Una vez que entiendas las necesidades de tu usuario, escribe las [Historias
de Usuario](https://es.wikipedia.org/wiki/Historias_de_usuario) que representen
todo lo que el usuario necesita hacer/ver. Asegúrate de incluir una definición
de terminado (_definition of done_) para cada una.

### Diseño de la Interfaz de Usuario

#### Prototipo de baja fidelidad

Durante tu trabajo deberás haber hecho e iterado sketches (boceto) de tu
solución usando papel y lápiz. Te recomendamos tomar fotos de todas las
iteraciones que realices y las subas a tu repositorio, y las menciones en tu
`README.md`.

#### Prototipo de alta fidelidad

Lo siguiente es diseñar tu Interfaz de Usuario (UI por sus siglas en inglés -
_User Interface_). Para eso debes aprender a utilizar alguna herramienta de
diseño visual. Nosotros te recomendamos [Figma](https://www.figma.com/) que es
una herramienta que funciona en el navegador y, además, puedes crear una cuenta
gratis. Sin embargo, eres libre de utilizar otros editores gráficos como
Illustrator, Photoshop, PowerPoint, Keynote, etc.


#### Testeos de usabilidad

Durante el reto deberás realizar tests de usabilidad con distintos usuarios, y
en base a los resultados de esos tests, deberás iterar tus diseños. Cuéntanos
qué problemas de usabilidad detectaste a través de los tests y cómo los
mejoraste en tu propuesta final.

### Implementación de la Interfaz de Usuario (HTML/CSS/JS)

Luego de diseñar tu interfaz de usuario deberás trabajar en su implementación.
Como mencionamos, **no** es necesario que construyas la interfaz tal como la
diseñaste. Tendrás un tiempo limitado para hackear, así es que deberás
priorizar.

Como mínimo, tu implementación debe:

1. Mostrar la data en una interfaz: puede ser un card, una tabla, una lista, etc.
2. Permitir al usuario filtrar y ordenar la data.
3. Calcular estadísticas de la colección (o subcolección) como media aritmética,
   máximo y/o mínimo de algún atributo numérico, o contar cuántas veces aparece
   un determinado valor, por ejemplo.
4. Visualizarse sin problemas desde distintos tamaños de pantallas: móviles,
   tablets y desktops.

Es importante que tu interfaz, a pesar de ser una versión mínima de tu ideal,
siga los fundamentos de _visual design_.

### Pruebas unitarias

El _boilerplate_ de este proyecto no incluye pruebas unitarias, pero esperamos
que escribas tus propias pruebas unitarias para las funciones encargadas de
_procesar_, _filtrar_ y _ordenar_ la data, así como _calcular_ estadísticas.
Para ello te recomendamos implementar las siguientes funciones en el archivo
`src/data.js`:

- `filterData(data, condition)`: esta función `filter` o filtrar recibiría la
  data, y nos retornaría aquellos datos que sí cumplan con la condición.

- `sortData(data, sortBy, sortOrder)`: esta función `sort` u ordenar
  recibe tres parámetros.
  El primer parámetro, `data`, nos entrega los datos.
  El segundo parámetro, `sortBy`, nos dice con respecto a cuál de los campos de
  la data se quiere ordenar.
  El tercer parámetro, `sortOrder`, indica si se quiere ordenar de manera
  ascendente o descendente.

- `computeStats(data)`: la función `compute` o calcular, nos permitirá hacer
  cálculos estadísticos básicos para ser mostrados de acuerdo a la data
  proporcionada.

Estas son propuestas de funciones que podrías implementar.

El archivo `src/data.js` debe tener una cobertura del 70% de _statements_
(_sentencias_), _functions_ (_funciones_), _lines_ (_líneas_), y _branches_
(_ramas_).

**Estas funciones deben ser [_puras_](https://medium.com/laboratoria-developers/introducci%C3%B3n-a-la-programaci%C3%B3n-funcional-en-javascript-parte-2-funciones-puras-b99e08c2895d)
e independientes del DOM**. Estas funciones serán después usadas desde el archivo
`src/main.js`, al cargar la página, y cada vez que el usuario interactúe (click,
filtrado, ordenado, ...).

## Hacker edition

Features/características extra sugeridas:

- En lugar de consumir la data estática brindada en este repositorio, puedes
  consumir la data de forma dinámica, cargando un archivo JSON por medio de
  `fetch`. La carpeta `src/data` contiene una versión `.js` y una `.json`
  de cada set datos.
- Agregarle a tu interfaz de usuario implementada visualizaciones gráficas. Para
  ello te recomendamos explorar librerías de gráficas como [Chart.js](https://www.chartjs.org/)
  o [Google Charts](https://developers.google.com/chart/).


## Consideraciones técnicas

La lógica del proyecto debe estar implementada completamente en JavaScript
(ES6), HTML y CSS. En este proyecto NO está permitido usar librerías o
frameworks, solo [vanilla JavaScript](https://medium.com/laboratoria-how-to/vanillajs-vs-jquery-31e623bbd46e),
con la excepción de librerías para hacer gráficas (charts); ver
[_Hacker Edition_](#parte-opcional-hacker-edition) más arriba.

No se debe utilizar la _pseudo-variable_ `this`.

El _boilerplate_ contiene una estructura de archivos como punto de partida así
como toda la configuración de dependencias:

```text
.
├── package.json
├── README.md
├── src
│   ├── data
│   │   ├── injuries
│   │   │   ├── injuries.js
│   │   │   └── injuries.json
│   │   ├── lol
│   │   │   ├── lol.js
│   │   │   └── lol.json
│   │   ├── pokemon
│   │   │   ├── pokemon.js
│   │   │   └── pokemon.json
│   │   ├── steam
│   │   │   ├── steam.js
│   │   │   └── steam.json
│   │   └── worldbank
│   │       ├── worldbank.js
│   │       └── worldbank.json
│   ├── data.js
│   ├── index.html
│   ├── main.js
│   └── style.css
└── test
    └── data.spec.js

8 directories, 17 files
```

### `src/index.html`

Al igual que en el proyecto anterior, existe un archivo `index.html`. Como ya
sabrás, acá va la página que se mostrará al usuario. También nos sirve para
indicar qué scripts se usarán y unir todo lo que hemos hecho.

En este archivo encontrarás una serie de _etiquetas_ (_tags_) `<script>`
_comentadas_. Para _cargar_ las diferentes fuentes de datos tendrás que
_descomentar_ estas _etiquetas_. Cada uno de estos scripts asignará una variable
global con la data correspondiente a esa fuente de datos.

Por ejemplo, si descomentamos la siguiente línea:

```html
<!-- <script src="./data/worldbank/worldbank.js"></script> -->
```

La línea quedaría así:

```html
<script src="./data/worldbank/worldbank.js"></script>
```

Y ahora tendríamos la variable global `WORLDBANK` disponible en nuestros otros
scripts (como `src/data.js` o `src/main.js`).

### `src/main.js`

Recomendamos usar `src/main.js` para todo tu código que tenga que ver con
mostrar los datos en la pantalla. Con esto nos referimos básicamente a la
interacción con el DOM. Operaciones como creación de nodos, registro de
manejadores de eventos (_event listeners_ o _event handlers_), ....

Esta no es la única forma de dividir tu código, puedes usar más archivos y
carpetas, siempre y cuando la estructura sea clara para tus compañeras.

### `src/data.js`

El corazón de este proyecto es la manipulación de datos a través de arreglos y
objetos. La idea de este archivo es contener toda la funcionalidad
que corresponda a obtener, procesar y manipular datos.

En este archivo esperamos que implementes las funciones detalladas en la sección
de [_Pruebas Unitarias_](#pruebas-unitarias).

### `src/data`

En esta carpeta están los datos de las diferentes fuentes. Encontrarás una
carpeta por cada fuente, y dentro de cada carpeta dos archivos: uno con la
extensión `.js` y otro `.json`. Ambos archivos contienen la misma data; la
diferencia es que el `.js` lo usaremos a través de una etiqueta `<script>`,
mientras que el `.json` está ahí para opcionalmente cargar la data de forma
asíncrona con [`fetch()`](https://developer.mozilla.org/es/docs/Web/API/Fetch_API)
(ver sección de [_Parte Opcional_](#parte-opcional-hacker-edition)).

### `test/data.spec.js`

Tendrás también que completar las pruebas unitarias de las funciones
implementadas en el archivo `data.js`.


---

## Pistas sobre cómo empezar a trabajar en el proyecto

Antes de empezar a escribir código, debes definir qué deberá hacer el producto
en base al conocimiento que puedas obtener de tu usuario. Estas preguntas te
pueden ayudar:

- ¿Quiénes son los principales usuarios de producto?
- ¿Cuáles son los objetivos de estos usuarios en relación con el producto?
- ¿Cuáles son los datos más relevantes que quieren ver en la interfaz y por qué?
- ¿Cuándo utilizan o utilizarían el producto?

Cuando ya estés lista para codear, te sugerimos empezar de esta manera:

1. Una de las integrantes del equipo debe realizar un :fork_and_knife:
   [fork](https://help.github.com/articles/fork-a-repo/) del repo de tu cohort,
   tus \_coaches\* te compartirán un \_link\* a un repo y te darán acceso de lectura
   en ese repo. La otra integrante del equipo deber hacer un fork **del
   repositorio de su compañera** y [configurar](https://gist.github.com/BCasal/026e4c7f5c71418485c1)
   un `remote` hacia el mismo.
2. :arrow_down: [Clona](https://help.github.com/articles/cloning-a-repository/)
   tu :fork_and_knife: [fork](https://help.github.com/articles/fork-a-repo/) a tu computadora (copia local).
3. 📦 Instala las dependencias del proyecto con el comando `npm install`. Esto
   asume que has instalado [Node.js](https://nodejs.org/) (que incluye [npm](https://docs.npmjs.com/)).
4. Si todo ha ido bien, deberías poder ejecutar las :traffic_light:
   pruebas unitarias (unit tests) con el comando `npm test`.
5. A codear se ha dicho! :rocket:

---

## Contenido de referencia

### Diseño de experiencia de usuario (User Experience Design)

- Investigación con usuarios / entrevistas
- Principios de diseño visual

### Desarrollo Front-end

- Unidad de testing en curso de JavaScript en LMS.
- Unidad de arreglos en curso de JavaScript en LMS.
- Unidad de objetos en curso de JavaScript en LMS.
- Unidad de funciones en curso de JavaScript en LMS.
- Unidad de DOM en curso de Browser JavaScript en LMS.
- [Array en MDN](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array)
- [Array.sort en MDN](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/sort)
- [Array.map en MDN](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/map)
- [Array.filter en MDN](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/filter)
- [Array.reduce en MDN](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/reduce)
- [Array.forEach en MDN](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/forEach)
- [Object.keys en MDN](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Object/keys)
- [Object.entries en MDN](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Object/entries)
- [Fetch API en MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
- [json.org](https://json.org/json-es.html)

### Herramientas

- [Git](https://git-scm.com/)
- [GitHub](https://github.com/)
- [GitHub Pages](https://pages.github.com/)
- [Node.js](https://nodejs.org/)
- [Jest](https://jestjs.io/)

---

## Checklist

- [ ] Usa VanillaJS.
- [ ] No hace uso de `this`.
- [ ] Pasa linter (`npm pretest`)
- [ ] Pasa tests (`npm test`)
- [ ] Pruebas unitarias cubren un mínimo del 70% de statements, functions y
      lines y branches.
- [ ] Incluye _Definición del producto_ clara e informativa en `README.md`.
- [ ] Incluye historias de usuario en `README.md`.
- [ ] Incluye _sketch_ de la solución (prototipo de baja fidelidad) en
      `README.md`.
- [ ] Incluye _Diseño de la Interfaz de Usuario_ (prototipo de alta fidelidad)
      en `README.md`.
- [ ] Incluye el listado de problemas que detectaste a través de tests de
      usabilidad en el `README.md`.
- [ ] UI: Muestra lista y/o tabla con datos y/o indicadores.
- [ ] UI: Permite ordenar data por uno o más campos (asc y desc).
- [ ] UI: Permite filtrar data en base a una condición.

## Checklist (Hacker Edition)

- [ ] Consume data de forma dinámica (`fetch()`).
- [ ] Utiliza Librerías de graficas (`chart.js` ó `google chart`).
- [ ] Cobertura de coverage al 100%.
